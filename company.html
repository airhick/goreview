<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Connexion Google</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' http://localhost:*; connect-src 'self' http://localhost:* https://vigutqmfosxbpncussie.supabase.co https://accounts.google.com https://www.google.com https://n8n.goreview.fr; img-src 'self' data: https: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://accounts.google.com https://www.google.com https://*.google.com https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://accounts.google.com https://*.google.com; style-src-elem 'self' 'unsafe-inline' https://accounts.google.com https://*.google.com; frame-src 'self' http://localhost:* https://accounts.google.com https://www.google.com https://*.google.com;">
  <script>
    // Suppress ONLY MCP/BrowserAutomation errors, keep all other errors visible
    (function(){
      const isMCPError = (msg) => {
        if (!msg) return false;
        const str = String(msg).toLowerCase();
        return str.includes('localhost:62462') || 
               str.includes('browserautomation') || 
               str.includes('registerwithmcp') || 
               str.includes('pollforcommands') ||
               (str.includes('vm') && str.includes('register-iframe'));
      };
      
      // Only suppress console errors that are MCP-related
      const originalError = console.error;
      console.error = function(...args) {
        const isMCP = args.some(arg => isMCPError(String(arg)));
        if (!isMCP) {
          originalError.apply(console, args);
        }
      };
      
      // Suppress fetch errors only for localhost:62462
      const originalFetch = window.fetch;
      window.fetch = function(...args) {
        if (args[0] && args[0].includes && args[0].includes('localhost:62462')) {
          return Promise.reject(new Error('Blocked by dev filter')).catch(() => {});
        }
        return originalFetch.apply(this, args);
      };
      
      // Suppress XMLHttpRequest errors only for localhost:62462
      const originalOpen = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function(method, url, ...rest) {
        if (url && url.includes('localhost:62462')) {
          this.addEventListener('error', () => {}, {once: true});
          this.addEventListener('loadend', () => {}, {once: true});
        }
        return originalOpen.apply(this, [method, url, ...rest]);
      };
    })();
  </script>
  <script src="https://accounts.google.com/gsi/client?hl=fr" async defer></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="db-proxy.js"></script>
  <style>
    /* Fond et typographie façon Google */
    body {
      background: #f6f7f9;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      color: #202124;
    }

    /* Carte centrale */
    .container {
      width: 100%;
      max-width: 380px;
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(60,64,67,.15);
      padding: 32px 32px 28px;
      text-align: center;
    }

    /* Logo Google */
    .g-logo {
      height: 36px;
      width: auto;
      margin: 0 auto 12px;
      display: block;
    }

    .title {
      font-size: 22px;
      font-weight: 600;
      margin: 0 0 4px;
      letter-spacing: .2px;
    }

    .subtitle {
      font-size: 14px;
      color: #5f6368;
      margin: 0 0 20px;
    }

    /* Consentement */
    .consent {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      text-align: left;
      margin: 0 0 16px;
      font-size: 13.5px;
      line-height: 1.4;
      color: #3c4043;
    }

    .consent input[type="checkbox"] {
      margin-top: 2px;
      transform: scale(1.05);
      cursor: pointer;
    }

    .consent a {
      color: #1a73e8;
      text-decoration: none;
    }

    .consent a:hover {
      text-decoration: underline;
    }

    /* Wrapper du bouton Google */
    #googleBtnWrapper {
      transition: opacity .2s ease, filter .2s ease;
    }

    #googleBtnWrapper.disabled {
      opacity: 0.55;
      filter: grayscale(10%);
      pointer-events: none;
    }

    /* Footer petit texte */
    .footnote {
      margin-top: 16px;
      font-size: 12px;
      color: #5f6368;
    }

    /* Game container - hidden by default */
    #gameContainer {
      display: none;
      width: 100%;
      max-width: 600px;
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(60,64,67,.15);
      padding: 32px;
      text-align: center;
    }

    /* Responsive styles */
    @media (max-width: 600px) {
      body {
        padding: 16px;
        align-items: flex-start;
        padding-top: 40px;
      }

      .container, #gameContainer {
        max-width: 100%;
        padding: 24px 20px 20px;
        border-radius: 8px;
      }

      .title {
        font-size: 20px;
      }

      .subtitle {
        font-size: 13px;
      }

      .consent {
        font-size: 12.5px;
        margin-bottom: 14px;
      }

      .footnote {
        font-size: 11px;
      }

      #googleBtn {
        width: 100% !important;
      }
    }

    @media (max-width: 400px) {
      .container, #gameContainer {
        padding: 20px 16px 18px;
      }

      .title {
        font-size: 18px;
      }

      .subtitle {
        font-size: 12px;
      }

      .g-logo {
        height: 32px;
      }
    }
  </style>
</head>
<body>
  <div id="loginContainer" class="container">
    <!-- Logo Google officiel en PNG -->
    <img class="g-logo" src="https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png" alt="Google">

    <h1 class="title">Se connecter</h1>
    <p class="subtitle">Utilisez votre compte Google</p>

    <div class="consent">
      <input type="checkbox" id="consentCheck">
      <label for="consentCheck">
        J'accepte la
        <a href="/pages/politique-de-confidentialite" target="_blank" rel="noopener">politique de confidentialité</a>.
      </label>
    </div>

    <div id="googleBtnWrapper" class="disabled">
      <div id="googleBtn" style="margin:auto; display:inline-block;"></div>
    </div>

    <div class="footnote">
      Protégé par Google reCAPTCHA • <a href="https://policies.google.com/privacy" target="_blank" rel="noopener" style="color:#1a73e8;text-decoration:none;">Confidentialité</a> · <a href="https://policies.google.com/terms" target="_blank" rel="noopener" style="color:#1a73e8;text-decoration:none;">Conditions</a>
    </div>
  </div>

  <!-- Game container - will be populated when user returns -->
  <div id="gameContainer"></div>

  <script>
    const wrapper = document.getElementById("googleBtnWrapper");
    const consent = document.getElementById("consentCheck");
    const loginContainer = document.getElementById('loginContainer');
    const gameContainer = document.getElementById('gameContainer');
    
    // Database proxy (webhook)
    
    let reviewWindow = null;
    let hasOpenedReview = false;
    let cachedBusinessId = null; // Cache le business_id pour éviter les appels répétés

    // Wait for db-proxy.js to load before using it
    window.waitForDbProxy = window.waitForDbProxy || async function() {
      if (window.dbProxy) {
        return window.dbProxy;
      }
      let retries = 0;
      while (!window.dbProxy && retries < 50) {
        await new Promise(resolve => setTimeout(resolve, 100));
        retries++;
      }
      if (!window.dbProxy) {
        throw new Error('db-proxy.js failed to load after 5 seconds');
      }
      return window.dbProxy;
    };

    // Récupérer l'ID depuis l'URL
    function getConfigId() {
      const params = new URLSearchParams(window.location.search);
      return params.get("id");
    }

    // Récupérer le business_id (place_id) depuis Supabase
    async function fetchBusinessId() {
      if (cachedBusinessId !== null) {
        return cachedBusinessId; // Utiliser le cache
      }
      
      const configId = getConfigId();
      if (!configId) return null;
      
      try {
        const dbProxy = await window.waitForDbProxy();
        const { data, error } = await dbProxy.select('accounts', { id: configId }, { select: ['business_id'], limit: 1, single: true });
        
        if (error) {
          console.error('Error fetching business_id:', error);
          // Try without select to get all fields
          try {
            const { data: allData, error: allError } = await dbProxy.select('accounts', { id: configId }, { limit: 1, single: true });
            if (!allError && allData) {
              cachedBusinessId = allData.business_id || allData.place_id || null;
              return cachedBusinessId;
            }
          } catch (fallbackError) {
            console.error('Fallback query also failed:', fallbackError);
          }
          return null;
        }
        
        cachedBusinessId = data?.business_id || null;
        return cachedBusinessId;
      } catch (e) {
        console.error('Error fetching business_id:', e);
        return null;
      }
    }

    // Charger et afficher le jeu depuis Supabase
    async function loadGame() {
      const configId = getConfigId();
      if (!configId) return;

      try {
        const dbProxy = await window.waitForDbProxy();
        const { data } = await dbProxy.select('accounts', { id: configId }, { select: ['wich_game', 'games_details', 'games'], limit: 1, single: true });
        
        if (!data || !data.games || !data.wich_game) {
          console.log('No game configured for this account');
          return;
        }

        const gameType = data.wich_game;
        const gamesDetails = data.games_details ? JSON.parse(data.games_details) : null;

        console.log('Loading game:', gameType, gamesDetails);

        // Masquer le login, afficher le jeu
        loginContainer.style.display = 'none';
        gameContainer.style.display = 'block';

        // Charger le jeu selon le type
        await loadGameByType(gameType, gamesDetails);
      } catch (e) {
        console.error('Error loading game:', e);
      }
    }

    // Charger le jeu selon son type
    async function loadGameByType(gameType, gameDetails) {
      // Charger le fichier HTML du jeu via fetch
      const gameUrl = `games/${gameType}.html`;
      
      try {
        const response = await fetch(gameUrl);
        if (!response.ok) {
          throw new Error(`Failed to load game: ${gameType}`);
        }
        
        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Extraire le contenu du body
        const gameContent = doc.body.innerHTML;
        
        // Injecter dans le container
        gameContainer.innerHTML = gameContent;
        
        // Exécuter les scripts du jeu
        const scripts = doc.querySelectorAll('script');
        scripts.forEach(script => {
          const newScript = document.createElement('script');
          if (script.src) {
            newScript.src = script.src;
          } else {
            newScript.textContent = script.textContent;
          }
          document.body.appendChild(newScript);
        });
        
        // Injecter les styles
        const styles = doc.querySelectorAll('style, link[rel="stylesheet"]');
        styles.forEach(style => {
          if (style.tagName === 'STYLE') {
            const newStyle = document.createElement('style');
            newStyle.textContent = style.textContent;
            document.head.appendChild(newStyle);
          } else if (style.tagName === 'LINK') {
            const newLink = document.createElement('link');
            newLink.rel = 'stylesheet';
            newLink.href = style.href;
            document.head.appendChild(newLink);
          }
        });

        // Initialiser le jeu avec les détails depuis Supabase
        if (gameDetails && window.initGame) {
          window.initGame(gameDetails);
        }
      } catch (e) {
        console.error('Error loading game file:', e);
        gameContainer.innerHTML = `<h2>Erreur de chargement du jeu</h2><p>${e.message}</p>`;
      }
    }

    // Détecter quand l'utilisateur revient sur la page
    function setupReturnDetection() {
      // Détecter le focus de la fenêtre
      window.addEventListener('focus', () => {
        if (hasOpenedReview && reviewWindow && reviewWindow.closed) {
          // La fenêtre de review a été fermée, charger le jeu
          console.log('Review window closed, loading game...');
          loadGame();
        }
      });

      // Détecter les changements de visibilité
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && hasOpenedReview && reviewWindow && reviewWindow.closed) {
          console.log('Page visible again, loading game...');
          loadGame();
        }
      });

      // Vérifier périodiquement si la fenêtre est fermée
      setInterval(() => {
        if (hasOpenedReview && reviewWindow && reviewWindow.closed) {
          console.log('Review window closed (interval check), loading game...');
          loadGame();
          hasOpenedReview = false; // Reset pour éviter de recharger plusieurs fois
        }
      }, 1000);
    }

    // Initialiser Google Sign-In au chargement de la page
    window.onload = async () => {
      // Vérifier si l'utilisateur revient (check localStorage ou sessionStorage)
      const hasReturned = sessionStorage.getItem('hasReturnedFromReview');
      if (hasReturned === 'true') {
        // L'utilisateur revient, charger le jeu directement
        loginContainer.style.display = 'none';
        await loadGame();
        sessionStorage.removeItem('hasReturnedFromReview');
        return;
      }

      // Sinon, initialiser le login Google
      setupReturnDetection();
      
      // Précharger le business_id pour éviter le délai lors du login
      await fetchBusinessId();
      
      google.accounts.id.initialize({
        client_id: "343360455562-t9deta89vmmm5jftdujo4bjsven90990.apps.googleusercontent.com",
        callback: handleCredentialResponse,
        locale: 'fr'
      });

      const btnWidth = window.innerWidth <= 600 ? (window.innerWidth - 64) : 320;
      google.accounts.id.renderButton(
        document.getElementById("googleBtn"),
        {
          theme: "outline",
          size: "large",
          width: btnWidth,
          locale: 'fr',
          text: 'signin_with'
        }
      );
    };

    consent.addEventListener("change", () => {
      if (consent.checked) {
        wrapper.classList.remove("disabled");
      } else {
        wrapper.classList.add("disabled");
      }
    });

    async function handleCredentialResponse(response) {
      const payload = JSON.parse(atob(response.credential.split('.')[1]));

      // Récupérer le business_id depuis la base de données si pas encore en cache
      let businessId = cachedBusinessId;
      if (!businessId) {
        businessId = await fetchBusinessId();
      }
      
      if (businessId) {
        const googleReviewUrl = `https://search.google.com/local/writereview?placeid=${businessId}`;
        console.log('Redirecting to Google Maps:', googleReviewUrl);
        
        // Rediriger directement vers Google Maps dans la même fenêtre
        window.location.href = googleReviewUrl;
      } else {
        console.error('No business_id found, cannot redirect to Google Maps');
        // Pas de business_id, charger le jeu directement
        sessionStorage.setItem('hasReturnedFromReview', 'true');
        loadGame();
      }

      // Send lead to webhook (en arrière-plan, non-bloquant)
      const configId = getConfigId();
      const webhookUrl = 'https://n8n.goreview.fr/webhook/add_lead';
      
      const leadPayload = {
        id: configId || null,
        nom: payload.family_name || null,
        prenom: payload.given_name || null,
        email: payload.email || null,
        google_id: payload.sub || null,
        timestamp: new Date().toISOString()
      };

      console.log('Sending lead to webhook:', leadPayload);

      // Basic Auth credentials
      const username = 'yck69';
      const password = 'yck69';
      const credentials = btoa(`${username}:${password}`);

      // Send to webhook (fire and forget - non-blocking)
      fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Basic ${credentials}`
        },
        body: JSON.stringify(leadPayload)
      })
      .then(response => {
        console.log('Webhook response status:', response.status);
        if (response.ok) {
          console.log('Lead sent successfully to webhook');
        } else {
          console.warn('Webhook returned non-OK status:', response.status);
        }
        return response.text();
      })
      .then(data => {
        console.log('Webhook response:', data);
      })
      .catch(err => {
        console.error('Webhook send failed (non-blocking):', err);
      });
    }
  </script>
</body>
</html>
